#+TITLE: Trabajo Práctico Integrador: C++ Avanzado
#+AUTHOR: Claribel Manzano; Gonzalo Fernández

El presente trabajo se responde a lo solicitado como trabajo práctico
integrador de la cátedra de *Programación Orientada a Objetos* de la
/Facultad de Ingeniería/ de la /Universidad Nacional de Cuyo/,
Mendoza, Argentina. Año 2018. Prof. Ing. César Aranda.
* Objetivos
El objetivo del trabajo consiste en controlar un robot de 3 grados de libertad con
efector final, a modo de simulación.
* Requerimientos generales
Dado que la cátedra es de programación orientada a objetos, la
resolución del problema planteado está representada e
implementada usando un *paradigma orientado a objetos*.\\
Está diseñado utilizando un *modelo de capas*, de manera que la solución
puede usarse independientemente de que haya interfaz gráfica o de
consola.
Debido a que el lenguaje de programación aprendido y utilizado durante
el cursado de la cátedra es *C++*, lenguaje que cumple los
requerimientos que tiene la solución del problema siendo uno de
los más indicados en problemas de éste tipo, se lo adoptó como
lenguaje principal del proyecto.
Todo el proyecto es desarrollado bajo *sistema operativo Linux*.
Para la implementación de la interfaz de usuario, es requerido que sea
gráfica, con interacción estándar mediante mouse y teclado. En este
caso se utiliza las *librerías del framework Qt5*.

* Robot simulado
El robot que se simula es un *modelo RRR*, lo que quiere decir que sus
tres grados de libertad corresponden a rotaciones. El tipo propuesto
es uno similar al modelo *Mitsubishi RV-2AJ*. 

** Modelo 3D del robot
La solución propuesta para la vista del robot en la interfaz, es que
ésta sea 3D.\\
Buscando en la web, se encontró en la página [[https://grabcad.com/library][GrabCad Community]] un gran
aporte de [[https://grabcad.com/filipe.barbosa-3][Filipe Barbosa]] de un robot [[https://grabcad.com/library/mitsubishi-rv-6s-1][Mitsubishi RV-6S Industrial MELFA
Series]] que responde al modelo RRR.

#+CAPTION: Render de modelo de robot Mitsubishi Industrial MELFA Series
#+NAME:   fig:RV-6S
[[./imgs/RV-6S.jpg]]

** Incorporación del modelo al proyecto
El modelo se encontraba en formato con extensión /.stp/. Para poder
utilizarlo correctamente en el framework Qt5, se convirtió el modelo a
formato /.obj/. El proceso de conversión fue de /.stp/ a un ensamble
de piezas en formato /.stl/, y con ayuda del software /Blender/,
se exportó este ensamble en una versión simplificada de 5 piezas en
formato /.obj/, que se encuentran en la carpeta [[./assets/][assets]].

* Instrucciones G-Code
El robot está configurado para recibir comandos similares al estándar
G-Code de RepRap. A continuación se enlista las instrucciones disponibles hasta el momento:

| Instrucción | Descripción                                                                                                                          |
|-------------+--------------------------------------------------------------------------------------------------------------------------------------|
| G0 AX PY    | *Consigna de posición*, donde X es la articulación a rotar e Y los grados.                                                           |
| G1 AX VY    | *Consigna de velocidad*, donde X es la articulación a setear velocidad e Y el valor de la velocidad en radianes por segundo [rad/s]. |
| G28         | *Homing* y/o *encender* robot.                                                                                                       |
| M0          | *Apagar* robot.                                                                                                                      |
| TX          | Cambio de *actividad del efector final*. Donde X es:\\+ 0: Pintar\\+ 1: Sostener\\+ 2: Soltar\\+ 3: Rotar                            |
| DXX         | *Duración de la actividad del efector final*, dada en segundos [s].                                                                  |
| EF          | *Inicio de actividad del efector final*.                                                                                             |

* Interfaz gráfica de usuario
Como ya se mencionó anteriormente, la interfaz gráfica de usuario se
diseña utilizando librerías proveídas por Qt, en este caso las
principales utilizadas son /QWidget/ y /QMainWindow/, y la ventana 3D
utilizando la librería /Qt3DCore/.
** Controles de cámara en la interfaz
Los controles configurados para la interfaz fueron tipo /Orbit
Controllers/, donde se hace zoom con el scroll del mouse, se traslada
con el click izquierdo y se rota con el click derecho.\\
[[./vids/3Dwindow.gif]]
** Panel de control

*** Ventana principal
El panel de control consiste en una ventana principal (clase
/Widget/), con botones que permiten el encendido y apagado del
robot.
El encendido procede automáticamente con un secuencia de movimientos
de homing. La acción de apagado frenará el robot en la posición en que
esté, dandole un estado inactivo.\\
Esta ventana principal también posee un cuadro de texto indicador del
estado global del robot (encendido o apagado) y otros dos cuadros de
texto que proveen la información del ángulo en que se encuentra cada
articulación, su velocidad relativa, e información de la
configuración del efector final.\\
Los botones "Establecer características iniciales", "Cargar archivo de
comandos" y "Comenzar movimiento" abren las otras respectivas
ventanas.\\
En el inferior de la ventana se encuentra el botón salir para cerrar
ésta.
*** Características
Desde la ventana principal, si se presiona el botón "Establecer
características iniciales", se abre la ventana de "Características".\\
En esta ventana el usuario puede introducir los parámetros que desee
del robot: Ángulos de las articulaciones y sus respectivas
velocidades. Una vez introducidos estos parámetros,  cuando el usuario
presione "Aceptar" estos datos serán cargados y si son diferentes a
los previos el robot procederá a ejecutar los movimientos
correspondientes.

*** Operación
Si desde la ventana principal el usuario presiona la ventana
principal, se abre la ventana de operación. Básicamente desde esta
ventana el usuario tiene completo control sobre el robot, y puede
moverlo ya sea introduciendo linea a linea comandos GCode en el cuadro
de texto correspondiente o controlando ángulo y velocidad de cada
articulación a través de los correspondientes sliders de la ventana.\\
En el inferior de la ventana se encuentra un botón para cargar un
archivo de comandos GCode y otro para realizar homing del robot.\\
El botón "Terminar" cierra la ventana.

*** Carga de archivo de comandos
Si desde la ventana principal o desde la ventana de operación, el
usuario presiona el botón para cargar archivo de comandos, se abrirá
una ventana con dos cuadros de texto y una pestaña superior.\\
La pestaña superior "File" puede presionarse, y se abrirá el gestor de
archivos correspondiente para que el usuario cargué su archivo de
texto con el programa de instrucciones GCode que desee ejecutar. Una
vez seleccionado, en un cuadro de texto de la ventana se pude observar
una vista preliminar del archivo y en el otro la ruta de éste.\\
En la parte inferior de la ventana se encuentran dos botones,
"Aceptar" y "Cancelar". El botón Aceptar cargará el programa
seleccionado y lo ejecutará, El botón Cancelar cerrará la ventana sin
que ninguna acción suceda.
* Descripción del control de la simulación
Como se mencionó antes, el proyecto está desarrollado en C++ basado en el framework Qt5,
específicamente la versión 5.11.\\
** Diagrama UML
El diagrama UML de la figura fue realizado con el software /Umbrello
UML Modeller/. Es provisorio ya que todavía está sujeto a cambios,
pero estos cambios no provocarías grandes modificaciones en la
estructura del proyecto y, por lo tanto, en el plano, sino más bien
son cambios que modificarían algunos métodos de la clase /BaseRobot/,
/Elemento/ y /Controller/.

#+CAPTION: Diagrama UML provisorio del proyecto.
#+NAME:   fig:UML
[[./imgs/diagramaUML.png]]
*** BaseRobot
Como puede observarse en el diagrama UML, la clase principal del proyecto
es la denominada /BaseRobot/, está clase es la encargada del manejo de
datos y comunicación con la interfaz gráfica de usuario. Es por esto
que la instanciación de BaseRobot en todo el proyecto es solo una, y
se ve agregada en todas las diferentes clases relacionadas con la
GUI.\\
Esta clase,  como muchas otras en el proyecto, hereda de /QObject/
librería perteneciente al framework utilizado.\\
En rasgos generales, tiene métodos para cargar archivo de texto con el
programa G-Code a realizar, método para la ejecución de dicho
programa gracias a otros de sus métodos más importantes que es el
/interprete de comando/ que como su nombre indica, interpreta cada
línea G-Code y la agraga a la cola de instrucciones (atributo de la
clase).\\
BaseRobot es la clase que posee métodos para la variación de los datos
correspondientes a la configuración del robot: sus ángulos y
velocidades. También posee información del /estado/ de éste: /activo/,
/inactivo/ y /en movimiento/, también información necesaria para la
comunicación con el robot: dirección IP y puerto de comunicación
(información no representativa para la simulación).\\
Otros métodos importantes en esta clase permiten tanto el apagado y
encendido del robot, como el comienzo de la ejecución de su cola de
instrucciones.\\
Respecto a la cola de instrucciones, como los movimientos del robot
están dados por clips de animación, cuándo cada uno de los clips
finaliza o, más general, cuándo una instrucción finaliza, se emite una
señal que es recibida por la clase para eliminar la instrucción de la
cola y continuar con la siguiente. También posee un método para
limpiar dicha cola, ésto sucede cuándo se realiza una maniobra de
/homing/ o cuándo se apaga la máuina.\\
Ésta clase agrega 4 objetos clase /Elemento/ y uno clase /Efector
Final/ que contienen la información relacionada a cada pieza "física"
del brazo.

*** Elemento
La clase /Elemento/ es la clase encargada de albergar toda la
información correspondiente a la pieza del brazo de su
instanciación. Su constructor recibe como parámetro el /rootEntity/ de
la entidad robot que se crea en BaseRobot. También hereda la librería
/QObject/ al igual que /BaseRobot/.\\
Los parámetros de esta clase están muy relacionados al render de la
pieza, del modelo /.obj/: un /mesh/ del modelo 3D en sí, un /material/
que provee el framework,  una /animación/ con la que se trabajará para
parametrizar los movimientos, una /transformación/, herramienta con la
que se ejecutan las traslaciones y rotaciones del mesh y una /entidad/ propia a la que se le agregas
los componentes anteriores.\\
Además de toda la información anterior, los métodos de la clase
permiten el get y set de los puntos, ejes y ángulos necesarios para
definir la configuración de la pieza. Otros métodos dan la
configuración de la animación, como la duración de ésta en base a la
velocidad seteada.\\
Cada elemento agrega un objeto clase /Controller/ que se describe más
adelante.

*** EfectorFinal
La clase /EfectorFinal/ es una clase que hereda de /Elemento/ y está
asociada al efector final del robot. En ella se encuentran métodos y
atributos para el control de la tarea que debe ejecutar y su
duración. Las posibles tareas son /pintar/, /sostener/, /soltar/ y
/rotar/.

*** Controller
La clase /Controller/ instancia los controladores de cada
/Elemento/. Estos controladores tienen como /target/ los atributos
/QTransform/ de cada elemento, es decir, manejan el aspecto de
transformación de los mesh de cada parte del robot. Esta manipulación
de la transformación es para dar los valores de la configuración de la
pieza en cada /frame/ de la animación. Por lo tanto, hay métodos
encadenados con métodos de la clase /Elemento/ correspondiente como los
get y set de los puntos, ejes y ángulos de la pieza.\\
La función más importante de la clase /Controller/ es la que actualiza
la matriz 4x4 característica de la transformación del elemento, donde
está la información correspondiente a traslaciones y rotaciones
ejecutadas sobre la pieza.\\
Existen señales internas en la clase que informan el cambio en el
ángulo o target seteado en la instanciación del controlador.

*** ConjuntoInterfaz
La clase /ConjuntoInterfaz/ es una superclase de todas aquellas
relacionadas con la interfaz gráfica de usuario.\\
Agrega a /BaseRobot/ y tiene como método una función que permite
setear éste atributo con la instancia de /BaseRobot/
correspondiente. Por lo que permite vincular a todas las clases
relacionadas con la GUI a las clases orientadas al control de la
simulación.

*** Otras clases
Las clases /Widget/, /DataList/, /ModoOperacion/ y /FileManager/ son
las relacionadas con la GUI. Para no extender la descripción del
código, no se realiza un análisis detallado de sus métodos y
atributos, éstos están muy relacionados con el diseño de las
diferentes ventanas asociadas que se describen en la sección de ésta
temática. Sin embargo, si vale resaltar que se implementan utilizando
/signals/,  /slots/ y objetos /ui/; donde gran parte del código es
generado automáticamente por el IDE de Qt /QtCreator/. Otro aspecto a
resaltar, es que estas clases tienen herencia múltiple: de la clase
/ConjuntoInterfaz/ como ya se mencionó, y de /QWidget/, librería
propia del framework como /QObject/. La librería /QWidget/ permite
dentro del IDE diseñar las ventanas de una forma más didáctica y
facilita la tarea con la herramienta /Design/. 

** Diagrama de secuencia temporal
El orden de instanciación de objetos al lanzar o ejecutar la
aplicación es como el que sigue:
[[
#+CAPTION: Diagrama de secuencia al lanzar la aplicación.
#+NAME:   fig:launch
./imgs/launch.png
]]
* Sonido
La simulación realiza una señal sonora cada vez que el robot inicia un
movimiento de rotación en alguno de sus grados de libertad. Esta
alarma sonora puede encontrarse en [[./assets/sound.wav]]. Este sonido se
puede implementar haciendo uso de la clase /QSound/ que provee el framework.
